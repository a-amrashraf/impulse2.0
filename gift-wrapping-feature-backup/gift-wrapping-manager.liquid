{% comment %}
  Gift Wrapping Manager JavaScript
  This code should be placed in layout/theme.liquid before the closing </body> tag
{% endcomment %}

{% if settings.cart_wrapping_enable %}
<script>
(function() {
  'use strict';

  function removeDuplicateWrappingContainers() {
    const containers = document.querySelectorAll('[data-wrapping-container]');
    if (containers.length <= 1) return;

    for (let index = 1; index < containers.length; index++) {
      containers[index].remove();
    }
  }

  removeDuplicateWrappingContainers();

  const dupObserver = new MutationObserver((mutations) => {
    const wrappingNodeTouched = mutations.some((mutation) => {
      return Array.from(mutation.addedNodes || []).some((node) => {
        if (!node || node.nodeType !== 1) return false;
        return node.matches?.('[data-wrapping-container]') || !!node.querySelector?.('[data-wrapping-container]');
      });
    });

    if (!wrappingNodeTouched) return;
    removeDuplicateWrappingContainers();
  });

  dupObserver.observe(document.body, {
    childList: true,
    subtree: true
  });

  if (!window.__giftWrappingToggleHandlerBound) {
    document.addEventListener('click', (event) => {
      const header = event.target.closest('[data-wrapping-toggle]');
      if (!header) return;

      const container = header.closest('[data-wrapping-container]');
      const itemsContainer = container?.querySelector('.wrapping-items-container');
      const toggleBtn = header.querySelector('.wrapping-toggle-btn');
      if (!itemsContainer || !toggleBtn) return;

      itemsContainer.classList.toggle('collapsed');
      toggleBtn.classList.toggle('collapsed');
    });

    window.__giftWrappingToggleHandlerBound = true;
  }

  const wrappingHandle = {{ settings.cart_wrapping_product_handle | default: 'special-wrapping' | json }};

  class GiftWrappingManager {
    constructor() {
      this.wrappingHandle = wrappingHandle;
      this.isUpdating = false;
      this.variantId = null;
      this.activeWrapItems = {};
      this.reloadTimeout = null;
    }

    async init() {
      try {
        if (this.isUpdating) {
          this.isUpdating = false;
        }

        if (!this.variantId) {
          this.variantId = await this.getWrappingVariantId();
        }

        this.attachCheckboxListeners();
        await this.syncCheckboxStateFromStorage();
      } catch (_) {
        this.isUpdating = false;
      }
    }

    saveStateByVariantId() {
      const checked = document.querySelectorAll('.wrapping-checkbox[data-item-key]:checked');
      const variantIds = new Set();

      checked.forEach((checkbox) => {
        const itemKey = checkbox.dataset.itemKey || '';
        const variantId = itemKey.split(':')[0];
        if (variantId) variantIds.add(variantId);
      });

      try {
        localStorage.setItem('gift_wrapping_variant_ids', JSON.stringify(Array.from(variantIds)));
      } catch (_) {}
    }

    async syncCheckboxStateFromStorage() {
      let savedVariantIds = [];

      try {
        const saved = localStorage.getItem('gift_wrapping_variant_ids');
        if (saved) savedVariantIds = JSON.parse(saved);
      } catch (_) {}

      const checkboxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]');
      checkboxes.forEach((checkbox) => {
        const itemKey = checkbox.dataset.itemKey || '';
        const variantId = itemKey.split(':')[0];

        if (savedVariantIds.includes(variantId)) {
          checkbox.checked = true;
          this.activeWrapItems[itemKey] = true;
        } else {
          checkbox.checked = false;
          delete this.activeWrapItems[itemKey];
        }
      });
    }

    isWrappingLineItem(checkbox, itemElement) {
      const itemKey = checkbox.dataset.itemKey || '';
      const wrappingItemKey = itemElement?.dataset.wrappingItem || '';
      const titleText = (itemElement?.querySelector('.wrapping-item-title')?.textContent || '').toLowerCase().trim();
      const variantId = itemKey.split(':')[0];

      return (
        wrappingItemKey.includes('special-wrapping') ||
        wrappingItemKey.includes('special wrapping') ||
        titleText === 'special wrapping' ||
        titleText === 'gift wrapping' ||
        titleText === 'special wrap' ||
        titleText.includes('special wrapping') ||
        titleText.includes('special wrap') ||
        titleText.includes('gift wrap') ||
        (this.variantId && variantId === this.variantId.toString())
      );
    }

    attachCheckboxListeners() {
      const allCheckboxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]');
      const wrappingItemsToRemove = [];

      allCheckboxes.forEach((checkbox) => {
        const itemElement = checkbox.closest('.wrapping-item');
        if (!itemElement) return;

        if (this.isWrappingLineItem(checkbox, itemElement)) {
          wrappingItemsToRemove.push(itemElement);
        }
      });

      wrappingItemsToRemove.forEach((item) => item.remove());

      const legitCheckboxes = Array.from(document.querySelectorAll('.wrapping-checkbox[data-item-key]'));
      legitCheckboxes.forEach((checkbox) => {
        const fresh = checkbox.cloneNode(true);
        checkbox.parentNode.replaceChild(fresh, checkbox);

        fresh.addEventListener('change', async (event) => {
          const key = event.target.dataset.itemKey;
          const isChecked = event.target.checked;

          if (isChecked) {
            this.activeWrapItems[key] = true;
          } else {
            delete this.activeWrapItems[key];
          }

          this.saveStateByVariantId();
          await this.updateWrappingFromChecked();
        });
      });
    }
    
    /**
     * Get total quantity of a product in the cart by variant ID
     * (sums across all entries of the same product)
     */
    async getProductQuantityInCart(variantId) {
      try {
        const cartResponse = await fetch('/cart.js?t=' + Date.now());
        const cart = await cartResponse.json();

        return cart.items.reduce((sum, item) => {
          if (item.variant_id.toString() === variantId.toString()) {
            return sum + item.quantity;
          }
          return sum;
        }, 0);
      } catch (_) {
        return 0;
      }
    }
    
    /**
     * Validate that wrapping quantity doesn't exceed product quantities
     * Returns the validated quantity (capped to what's actually available)
     */
    async validateWrappingQuantity() {
      try {
        const checkedBoxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]:checked');
        const productVariantMap = new Map();

        for (const checkbox of checkedBoxes) {
          const itemKey = checkbox.dataset.itemKey;
          const variantId = itemKey.split(':')[0];
          const quantity = parseInt(checkbox.dataset.itemQuantity || 1, 10);

          if (!productVariantMap.has(variantId)) {
            productVariantMap.set(variantId, 0);
          }

          productVariantMap.set(variantId, productVariantMap.get(variantId) + quantity);
        }

        const errors = [];
        for (const [variantId, checkedCount] of productVariantMap.entries()) {
          const cartQuantity = await this.getProductQuantityInCart(variantId);
          if (checkedCount > cartQuantity) {
            errors.push({ checkedCount, cartQuantity });
          }
        }

        if (errors.length > 0) {
          alert(`Unable to wrap all selected items:\n\n${errors.map(({ checkedCount, cartQuantity }) => `You selected to wrap ${checkedCount} items, but only ${cartQuantity} available in cart`).join('\n\n')}`);
          return false;
        }

        return true;
      } catch (_) {
        return false;
      }
    }
    
    /**
     * Calculate total quantity from checked boxes and sync to cart
     */
    async updateWrappingFromChecked() {
      if (this.isUpdating) return;

      this.isUpdating = true;
      const timeout = setTimeout(() => {
        this.isUpdating = false;
      }, 10000);

      try {
        const checkedBoxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]:checked');
        const totalToWrap = Array.from(checkedBoxes).reduce((sum, checkbox) => {
          return sum + parseInt(checkbox.dataset.itemQuantity || 1, 10);
        }, 0);

        if (totalToWrap > 0) {
          const isValid = await this.validateWrappingQuantity();
          if (!isValid) return;
        }

        await this.syncWrappingToCart(totalToWrap);
      } finally {
        clearTimeout(timeout);
        this.isUpdating = false;
      }
    }
    
    /**
     * Sync wrapping quantity to cart with product names
     */
    async syncWrappingToCart(quantity) {
      try {
        const cartResponse = await fetch('/cart.js?t=' + Date.now());
        const cart = await cartResponse.json();
        const wrappingItem = cart.items.find((item) => item.handle === this.wrappingHandle);
        const wrappedProductNames = this.getWrappedProductNames();
        const isEmpty = !wrappedProductNames || wrappedProductNames.trim() === '';

        if (isEmpty) {
          if (wrappingItem) {
            await this.updateCartItem(wrappingItem.key, 0);
          }

          try {
            localStorage.removeItem('gift_wrapping_variant_ids');
          } catch (_) {}
        } else if (wrappingItem) {
          const currentWrappedNames = wrappingItem.properties?.wrapped_products || '';
          const namesMatch = currentWrappedNames === wrappedProductNames;
          const quantityMatch = wrappingItem.quantity === quantity;

          if (!quantityMatch || !namesMatch) {
            await this.updateCartItem(wrappingItem.key, quantity, wrappedProductNames);
          }
        } else {
          await this.addWrappingProduct(quantity, wrappedProductNames);
        }

        setTimeout(() => this.refreshCartUI(), 150);
      } catch (_) {
        this.isUpdating = false;
      }
    }

    /**
     * Get names of all wrapped products
     */
    getWrappedProductNames() {
      const checkedBoxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]:checked');
      const names = Array.from(checkedBoxes).map((checkbox) => {
        const parent = checkbox.closest('.wrapping-item');
        return parent?.querySelector('.wrapping-item-title')?.textContent?.trim() || 'Unknown Product';
      });

      return names.join(', ');
    }
    
    /**
     * Add wrapping product to cart
     */
    async addWrappingProduct(quantity, wrappedProductNames = '') {
      if (!this.variantId) {
        this.variantId = await this.getWrappingVariantId();
      }

      const properties = {
        '_gift_wrapping': 'true'
      };

      if (wrappedProductNames) {
        properties.wrapped_products = wrappedProductNames;
      }

      const response = await fetch('/cart/add.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        },
        body: JSON.stringify({
          items: [{
            id: this.variantId,
            quantity: quantity,
            properties: properties
          }]
        })
      });

      if (!response.ok) {
        throw new Error('Failed to add wrapping product');
      }

      return response.json();
    }
    
    /**
     * Update item quantity in cart (and properties if provided)
     */
    async updateCartItem(key, quantity, wrappedProductNames = '') {
      const payload = {
        id: key,
        quantity: quantity
      };

      if (wrappedProductNames) {
        payload.properties = {
          wrapped_products: wrappedProductNames
        };
      }

      const response = await fetch('/cart/change.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      return response.json();
    }
    
    /**
     * Fetch wrapping product variant ID
     */
    async getWrappingVariantId() {
      const response = await fetch(`/products/${this.wrappingHandle}.js`);
      if (!response.ok) {
        throw new Error(`Product not found: ${this.wrappingHandle} (HTTP ${response.status})`);
      }

      const product = await response.json();
      if (!product.variants || product.variants.length === 0) {
        throw new Error(`No variants found for ${this.wrappingHandle}`);
      }

      return product.variants[0].id;
    }
    
    /**
     * Refresh cart display
     */
    refreshCartUI() {
      if (this.reloadTimeout) {
        clearTimeout(this.reloadTimeout);
      }

      if (typeof theme !== 'undefined' && theme.cart && typeof theme.cart.buildCart === 'function') {
        try {
          theme.cart.buildCart();
          return;
        } catch (_) {}
      }

      try {
        document.dispatchEvent(new CustomEvent('cart:update'));
      } catch (_) {}

      this.reloadTimeout = setTimeout(() => {
        window.location.reload();
      }, 2500);
    }
  }
  
  // Global instance
  window.giftWrappingManager = null;
  
  async function initGiftWrapping() {
    // Remove any duplicates first
    removeDuplicateWrappingContainers();
    
    const container = document.querySelector('[data-wrapping-container]');
    
    if (container) {
      if (!window.giftWrappingManager) {
        window.giftWrappingManager = new GiftWrappingManager();
      }
      
      await window.giftWrappingManager.init();
    }
  }
  
  /**
   * Watch for the wrapping container to appear in the DOM
   * This handles cases where cart is loaded dynamically
   */
  function watchForWrappingContainer() {
    const observer = new MutationObserver((mutations) => {
      const container = document.querySelector('[data-wrapping-container]');
      if (container) {
        observer.disconnect();
        initGiftWrapping();
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: false
    });
  }
  
  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initGiftWrapping();
      watchForWrappingContainer();
    });
  } else {
    initGiftWrapping();
    watchForWrappingContainer();
  }
  
  // Reinitialize after cart updates
  document.addEventListener('cart:updated', () => setTimeout(initGiftWrapping, 120));
  
  // Hook into theme cart system
  if (typeof theme !== 'undefined') {
    const hookCartBuild = () => {
      if (theme.cart && theme.cart.reInit) {
        const originalReInit = theme.cart.reInit;
        theme.cart.reInit = function() {
          originalReInit.call(this);
          setTimeout(initGiftWrapping, 80);
        };
      }
    };
    
    hookCartBuild();
  } else {
    setTimeout(() => {
      if (typeof theme !== 'undefined' && theme.cart && theme.cart.reInit) {
        const originalReInit = theme.cart.reInit;
        theme.cart.reInit = function() {
          originalReInit.call(this);
          setTimeout(initGiftWrapping, 80);
        };
      }
    }, 1500);
  }
})();
</script>
{% endif %}
