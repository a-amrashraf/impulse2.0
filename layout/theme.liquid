<!doctype html>
<html class="no-js" lang="{{ request.locale.iso_code }}" dir="{{ settings.text_direction }}">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="theme-color" content="{{ settings.color_button }}">
  <link rel="canonical" href="{{ canonical_url }}">
  <link rel="preconnect" href="https://cdn.shopify.com" crossorigin>
  <link rel="preconnect" href="https://fonts.shopifycdn.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="dns-prefetch" href="https://productreviews.shopifycdn.com">
  <link rel="dns-prefetch" href="https://ajax.googleapis.com">
  <link rel="dns-prefetch" href="https://maps.googleapis.com">
  <link rel="dns-prefetch" href="https://maps.gstatic.com">

  {%- if settings.favicon != blank -%}
    <link rel="shortcut icon" href="{{ settings.favicon | img_url: '32x32' }}" type="image/png" />
  {%- endif -%}

  {%- render 'seo-title' -%}

  {%- if page_description -%}
  <meta name="description" content="{{ page_description | escape }}">
  {%- endif -%}

  {%- render 'social-meta-tags' -%}

  {%- render 'font-face' -%}
  {{ 'theme.css' | asset_url | stylesheet_tag: preload: true }}
  {%- render 'css-variables' -%}

  <script>
    document.documentElement.className = document.documentElement.className.replace('no-js', 'js');

    window.theme = window.theme || {};
    theme.routes = {
      home: "{{ routes.root_url }}",
      cart: "{{ routes.cart_url | append: '.js' }}",
      cartPage: "{{ routes.cart_url }}",
      cartAdd: "{{ routes.cart_add_url | append: '.js' }}",
      cartChange: "{{ routes.cart_change_url | append: '.js' }}",
      search: "{{ routes.search_url }}",
      predictiveSearch: "{{ routes.predictive_search_url }}"
    };
    theme.strings = {
      soldOut: {{ 'products.product.sold_out' | t | json }},
      unavailable: {{ 'products.product.unavailable' | t | json }},
      inStockLabel: {{ 'products.product.in_stock_label' | t | json }},
      oneStockLabel: {{ 'products.product.stock_label.one' | t: count: '[count]' | json }},
      otherStockLabel: {{ 'products.product.stock_label.other' | t: count: '[count]' | json }},
      willNotShipUntil: {{ 'products.product.will_not_ship_until' | t: date: '[date]' | json }},
      willBeInStockAfter: {{ 'products.product.will_be_in_stock_after' | t: date: '[date]' | json }},
      waitingForStock: {{ 'products.product.waiting_for_stock' | t | json }},
      savePrice: {{ 'products.general.save_html' | t: saved_amount: '[saved_amount]' | json }},
      cartEmpty: {{ 'cart.general.empty' | t | json }},
      cartTermsConfirmation: {{ 'cart.general.terms_confirm' | t | json }},
      searchCollections: {{ 'general.search.collections' | t | json }},
      searchPages: {{ 'general.search.pages' | t | json }},
      searchArticles: {{ 'general.search.articles' | t | json }},
      productFrom: {{ 'products.general.from_text_html' | t: price: '' | json }},
      maxQuantity: {{ 'cart.general.max_quantity' | t: quantity: '[quantity]', title: '[title]' | json }}
    };
    theme.settings = {
      cartType: {{ settings.cart_type | json }},
      isCustomerTemplate: {% if request.page_type contains 'customers/' %}true{% else %}false{% endif %},
      moneyFormat: {{ shop.money_format | json }},
      saveType: {{ settings.product_save_type | json }},
      productImageSize: {{ settings.product_grid_image_size | json }},
      productImageCover: {{ settings.product_grid_image_fill }},
      predictiveSearch: {{ settings.predictive_search_enabled }},
      predictiveSearchType: {{ settings.search_type | json }},
      predictiveSearchVendor: {{ settings.predictive_search_show_vendor | json }},
      predictiveSearchPrice: {{ settings.predictive_search_show_price | json }},
      quickView: {{ settings.quick_shop_enable }},
      themeName: 'Impulse',
      themeVersion: "8.0.0"
    };
  </script>

  {{ content_for_header }}

  <script src="{{ 'vendor-scripts-v11.js' | asset_url | split: '?' | first }}" defer="defer"></script>

  {%- if shop.enabled_currencies.size > 1 -%}
    <link rel="stylesheet" href="{{ 'country-flags.css' | asset_url | split: '?' | first }}">
  {%- endif -%}

  <script src="{{ 'theme.js' | asset_url }}" defer="defer"></script>

  {%- if request.page_type contains 'customers/' -%}
    <script src="{{ 'shopify_common.js' | shopify_asset_url }}" defer="defer"></script>
  {%- endif -%}

  {% if request.design_mode %}
    <script>theme.settings.email = {{ shop.email | json }}</script>
    <script src="https://api.archetypethemes.co/design-mode.js" defer="defer"></script>
  {% endif %}
</head>

<body class="template-{{ template | replace: '.', ' ' | truncatewords: 1, '' | handle }}{% if request.path == '/challenge' %} template-challange{% endif %}" data-center-text="{{ settings.type_body_align_text }}" data-button_style="{{ settings.button_style }}" data-type_header_capitalize="{{ settings.type_header_capitalize }}" data-type_headers_align_text="{{ settings.type_headers_align_text }}" data-type_product_capitalize="{{ settings.type_product_capitalize }}" data-swatch_style="{{ settings.swatch_style }}" {% if settings.disable_animations %}data-disable-animations="true"{% endif %}>

  <a class="in-page-link visually-hidden skip-link" href="#MainContent">{{ 'general.accessibility.skip_to_content' | t }}</a>

  <div id="PageContainer" class="page-container">
    <div class="transition-body">

    {%- sections 'header-group' -%}
    {%- sections 'popup-group' -%}

      <main class="main-content" id="MainContent">
        {{ content_for_layout }}
      </main>

    {%- sections 'footer-group' -%}

    </div>
  </div>

  {%- liquid
    render 'video-modal'
    render 'photoswipe-template'
    render 'tool-tip'
  -%}

  {% comment %} Image markup used when building product grid item via JS {% endcomment %}
  <template id="naturalImageMarkup">
    <div class="image-wrap" style="height: 0;">
      <image-element data-aos="image-fade-in" data-aos-offset="150">
        <img class="grid-product__image image-element" width height src srcset loading="lazy" alt>
      </image-element>
    </div>
  </template>
  <template id="fixedRatioImageMarkup">
    <div class="grid__image-ratio">
      <image-element data-aos="image-fade-in" data-aos-offset="150">
        <img class="image-element" width height src srcset loading="lazy" alt>
      </image-element>
    </div>
  </template>







{% comment %} <style>
.site-header {
  position: fixed;
  top: 15px;
  left: 0;
  width: 100%;
  z-index: 9999;
  transition: top 0.3s ease-in-out;
}
</style>

<script>
document.addEventListener("DOMContentLoaded", function () {
  let lastScroll = window.pageYOffset;
  const header = document.querySelector(".site-header");

  window.addEventListener("scroll", function () {
    let currentScroll = window.pageYOffset;

    if (currentScroll > lastScroll && currentScroll > 50) {
      // Scroll down ‚Üí hide header
      header.style.top = `-${header.offsetHeight}px`;
    } else {
      // Scroll up ‚Üí show header
      header.style.top = "15px";
    }

    lastScroll = currentScroll;
  });
});
</script>

<style>
  @media only screen and (max-width: 768px) {
  .collection-filter {
    flex-wrap: wrap;
    justify-content: space-between;
    position: static !important;

    top: 17px;
    z-index: 5;
  }
}</style> {% endcomment %}

{% if settings.cart_wrapping_enable %}
<script>
(function() {
  'use strict';
  
  const wrappingHandle = {{ settings.cart_wrapping_product_handle | default: 'special-wrapping' | json }};
  
  class GiftWrappingManager {
    constructor() {
      this.wrappingHandle = wrappingHandle;
      this.isUpdating = false;
      this.cartItemState = {};
      this.activeWrapItems = {};
      this.variantId = null;
      this.isInitialized = false; // Prevent duplicate initializations
    }
    
    async init() {
      console.log('üéÅ Gift Wrapping Manager init started');
      
      // Prevent re-initialization (avoid duplicate wrapping adds)
      if (this.isInitialized) {
        console.log('‚ö†Ô∏è  Gift Wrapping already initialized, skipping...');
        return;
      }
      this.isInitialized = true;
      
      try {
        // Reset stuck state flags
        if (this.isUpdating) {
          console.log('‚ö†Ô∏è  Resetting stuck isUpdating flag');
          this.isUpdating = false;
        }
        
        // Fetch and cache the wrapping variant ID on init
        if (!this.variantId) {
          this.variantId = await this.getWrappingVariantId();
          console.log('‚úÖ Wrapping variant ID cached:', this.variantId);
        }
        
        // Attach listeners to all checkboxes
        this.attachCheckboxListeners();
        
        // Sync checkbox visual states - this restores from saved variant IDs
        await this.syncCheckboxStateFromStorage();
        
        // DO NOT call updateWrappingFromChecked() on init to avoid re-adding wrapping
        // The wrapping product should already be in the cart at the correct quantity
        // Only sync when user manually toggles a checkbox
        
        console.log('‚úÖ Gift wrapping initialized successfully');
      } catch (error) {
        console.error('‚ùå Gift wrapping init failed:', error);
        this.isUpdating = false;
      }
    }
    
    /**
     * Save wrapped items by variant ID (persists across item key changes)
     */
    saveStateByVariantId() {
      const checkboxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]:checked');
      const wrappedVariantIds = new Set();
      
      checkboxes.forEach(cb => {
        // Extract variant ID from item key (format: variantId:hash)
        const itemKey = cb.dataset.itemKey;
        const variantId = itemKey.split(':')[0];
        wrappedVariantIds.add(variantId);
      });
      
      try {
        const saved = Array.from(wrappedVariantIds);
        localStorage.setItem('gift_wrapping_variant_ids', JSON.stringify(saved));
        console.log('üíæ Saved wrapped variant IDs to storage:', saved);
      } catch (e) {
        console.warn('‚ö†Ô∏è  Could not save variant IDs to localStorage:', e.message);
      }
    }

    /**
     * Restore checkbox states from saved variant IDs
     */
    async syncCheckboxStateFromStorage() {
      // Load saved variant IDs from localStorage
      let savedVariantIds = [];
      try {
        const saved = localStorage.getItem('gift_wrapping_variant_ids');
        if (saved) {
          savedVariantIds = JSON.parse(saved);
          console.log('üì¶ Loaded wrapped variant IDs from storage:', savedVariantIds);
        }
      } catch (e) {
        console.warn('‚ö†Ô∏è  Could not load from localStorage:', e.message);
      }
      
      // Apply saved state to checkboxes based on variant ID
      const checkboxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]');
      checkboxes.forEach(checkbox => {
        const itemKey = checkbox.dataset.itemKey;
        const variantId = itemKey.split(':')[0];
        
        // Check if this variant ID was previously wrapped
        if (savedVariantIds.includes(variantId)) {
          checkbox.checked = true;
          // Track in memory
          this.activeWrapItems[itemKey] = true;
          console.log('‚úÖ Restored checkbox for variant:', variantId);
        } else {
          checkbox.checked = false;
          delete this.activeWrapItems[itemKey];
        }
      });
    }
    
    /**
     * Attach change listeners to all checkboxes
     */
    attachCheckboxListeners() {
      console.log('üîç attachCheckboxListeners called - scanning DOM...');
      
      // Get ALL checkboxes first
      const allCheckboxesRaw = document.querySelectorAll('.wrapping-checkbox[data-item-key]');
      console.log('üì¶ Total checkboxes found in DOM:', allCheckboxesRaw.length);
      
      // Log each checkbox for debugging
      allCheckboxesRaw.forEach((cb, idx) => {
        const parent = cb.closest('.wrapping-item');
        const itemKey = cb.dataset.itemKey;
        const titleEl = parent?.querySelector('.wrapping-item-title');
        const titleText = titleEl?.textContent?.trim() || 'Unknown';
        console.log(`  [${idx}] Title: "${titleText}", Key: ${itemKey}`);
      });
      
      // IMPORTANT: First pass - remove any wrapping product checkboxes from DOM entirely
      const wrappingItemsToRemove = [];
      allCheckboxesRaw.forEach(cb => {
        const parent = cb.closest('.wrapping-item');
        if (!parent) return;
        
        const itemKey = cb.dataset.itemKey;
        const wrappingItemKey = parent.dataset.wrappingItem;
        const titleEl = parent.querySelector('.wrapping-item-title');
        const titleText = (titleEl?.textContent || '').toLowerCase().trim();
        
        // Extract variant ID for comparison
        const variantId = itemKey.split(':')[0];
        
        // VERY aggressive detection - check EVERYTHING
        const isWrappingProduct = 
          // Check handle in data attribute
          wrappingItemKey?.includes('special-wrapping') ||
          wrappingItemKey?.includes('special wrapping') ||
          // Check product title text
          titleText === 'special wrapping' ||
          titleText === 'gift wrapping' ||
          titleText === 'special wrap' ||
          titleText.includes('special wrapping') || 
          titleText.includes('special wrap') ||
          titleText.includes('gift wrap') ||
          // Variant ID comparison (if this.variantId is set)
          (this.variantId && variantId === this.variantId.toString());
        
        if (isWrappingProduct) {
          console.log('üóëÔ∏è  DETECTED WRAPPING PRODUCT - Removing from DOM:', titleText, '(Key:', itemKey, ', Variant:', variantId, ', This Variant ID:', this.variantId, ')');
          wrappingItemsToRemove.push(parent);
        }
      });
      
      // Remove detected wrapping products
      wrappingItemsToRemove.forEach(item => {
        item.remove();
      });
      
      console.log('üóëÔ∏è  Removed', wrappingItemsToRemove.length, 'wrapping product item(s) from DOM');
      
      // Now get only the legitimate product checkboxes
      let checkboxes = Array.from(document.querySelectorAll('.wrapping-checkbox[data-item-key]'));
      console.log('‚úÖ Final legitimate checkboxes to listen to:', checkboxes.length);
      checkboxes.forEach((cb, idx) => {
        const parent = cb.closest('.wrapping-item');
        const titleEl = parent?.querySelector('.wrapping-item-title');
        console.log(`  [${idx}] ${titleEl?.textContent?.trim()}`);
      });
      
      checkboxes.forEach(checkbox => {
        // Clone to remove old listeners
        const newCheckbox = checkbox.cloneNode(true);
        checkbox.parentNode.replaceChild(newCheckbox, checkbox);
        
        // Attach new listener
        newCheckbox.addEventListener('change', (e) => {
          const key = e.target.dataset.itemKey;
          console.log('‚úì Checkbox changed:', key, 'Checked:', e.target.checked);
          
          if (e.target.checked) {
            this.activeWrapItems[key] = true;
          } else {
            delete this.activeWrapItems[key];
          }
          
          // Save state by variant ID (survives item key changes)
          this.saveStateByVariantId();
          
          console.log('üîÑ Triggering wrapping update...');
          // Immediately update cart
          this.updateWrappingFromChecked();
        });
      });
    }
    
    /**
     * Get total quantity of a product in the cart by variant ID
     * (sums across all entries of the same product)
     */
    async getProductQuantityInCart(variantId) {
      try {
        const cartResponse = await fetch('/cart.js');
        const cart = await cartResponse.json();
        
        // Sum all quantities for this variant ID
        const totalQuantity = cart.items.reduce((sum, item) => {
          if (item.variant_id.toString() === variantId.toString()) {
            return sum + item.quantity;
          }
          return sum;
        }, 0);
        
        console.log(`üì¶ Product variant ${variantId} total quantity in cart: ${totalQuantity}`);
        return totalQuantity;
      } catch (error) {
        console.error('‚ùå Error getting product quantity:', error);
        return 0;
      }
    }
    
    /**
     * Validate that wrapping quantity doesn't exceed product quantities
     * Returns the validated quantity (capped to what's actually available)
     */
    async validateWrappingQuantity() {
      try {
        const checkedBoxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]:checked');
        const productVariantMap = new Map(); // variant ID -> { checkedCount, cartQuantity }
        
        // Group checked items by product variant
        for (const cb of checkedBoxes) {
          const itemKey = cb.dataset.itemKey;
          const variantId = itemKey.split(':')[0];
          const quantity = parseInt(cb.dataset.itemQuantity || 1);
          
          if (!productVariantMap.has(variantId)) {
            productVariantMap.set(variantId, { checkedCount: 0, cartQuantity: 0 });
          }
          
          const entry = productVariantMap.get(variantId);
          entry.checkedCount += quantity;
        }
        
        // For each product variant, check if quantity is valid
        let errors = [];
        for (const [variantId, data] of productVariantMap.entries()) {
          const cartQuantity = await this.getProductQuantityInCart(variantId);
          data.cartQuantity = cartQuantity;
          
          if (data.checkedCount > cartQuantity) {
            errors.push(`Product variant ${variantId}: trying to wrap ${data.checkedCount} but only ${cartQuantity} in cart`);
          }
        }
        
        if (errors.length > 0) {
          console.warn('‚ö†Ô∏è  Wrapping quantity validation errors:');
          errors.forEach(err => console.warn('  - ' + err));
          
          // Show user-friendly alert
          alert(`Unable to wrap all selected items:\n\n${errors.map(err => {
            const match = err.match(/trying to wrap (\d+) but only (\d+)/);
            return match ? `You selected to wrap ${match[1]} items, but only ${match[2]} available in cart` : err;
          }).join('\n\n')}`);
          
          return false; // Don't proceed with wrapping
        }
        
        console.log('‚úÖ Wrapping quantity validation passed');
        return true; // Validation passed
      } catch (error) {
        console.error('‚ùå Error validating wrapping quantity:', error);
        return false;
      }
    }
    
    /**
     * Calculate total quantity from checked boxes and sync to cart
     */
    async updateWrappingFromChecked() {
      if (this.isUpdating) {
        console.log('‚è≥ Already updating, skipping...');
        return;
      }
      this.isUpdating = true;
      
      // Safety timeout to prevent stuck state
      const timeout = setTimeout(() => {
        if (this.isUpdating) {
          console.warn('‚ö†Ô∏è  Update timeout - forcing reset');
          this.isUpdating = false;
        }
      }, 10000);
      
      try {
        // Validate wrapping quantities first
        const isValid = await this.validateWrappingQuantity();
        if (!isValid) {
          console.log('‚ùå Wrapping quantity validation failed, aborting syncing');
          clearTimeout(timeout);
          this.isUpdating = false;
          return;
        }
        
        const checkedBoxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]:checked');
        const totalToWrap = Array.from(checkedBoxes).reduce((sum, cb) => {
          return sum + parseInt(cb.dataset.itemQuantity || 1);
        }, 0);
        
        console.log('üìä Total items to wrap:', totalToWrap);
        console.log('üìä Checked boxes count:', checkedBoxes.length);
        
        // CRITICAL: If no checkboxes are checked, we must remove wrapping
        if (totalToWrap === 0) {
          console.log('‚ö†Ô∏è  No items selected for wrapping - will remove wrapping product');
        }
        
        await this.syncWrappingToCart(totalToWrap);
      } finally {
        clearTimeout(timeout);
        this.isUpdating = false;
      }
    }
    
    /**
     * Sync wrapping quantity to cart with product names
     */
    async syncWrappingToCart(quantity) {
      try {
        console.log('üì§ Syncing wrapping to cart. Quantity:', quantity);
        
        // Get current cart
        const cartResponse = await fetch('/cart.js?t=' + Date.now()); // Cache bust
        const cart = await cartResponse.json();
        console.log('üõí Current cart items:', cart.items.length);
        cart.items.forEach((item, idx) => {
          console.log(`  [${idx}] ${item.product_handle} (qty: ${item.quantity}, variant: ${item.variant_id})`);
        });
        
        // Find wrapping item in cart
        const wrappingItem = cart.items.find(item => 
          item.product_handle === this.wrappingHandle
        );
        console.log('üéÅ Wrapping item in cart:', wrappingItem ? 'YES' : 'NO');
        if (wrappingItem) {
          console.log('   Key:', wrappingItem.key, 'Qty:', wrappingItem.quantity);
        }
        
        // Get wrapped product names
        const wrappedProductNames = this.getWrappedProductNames();
        console.log('üìù Wrapped product names:', wrappedProductNames);
        
        // Logic: if quantity > 0, need wrapping; if 0, remove it
        if (quantity > 0) {
          if (wrappingItem) {
            // IMPORTANT: Check if it's the SAME quantity AND already has the right properties
            // Only update if quantity changed OR product names changed
            const currentWrappedNames = wrappingItem.properties?.wrapped_products || '';
            const namesMatch = currentWrappedNames === wrappedProductNames;
            const quantityMatch = wrappingItem.quantity === quantity;
            
            if (!quantityMatch || !namesMatch) {
              console.log('‚¨ÜÔ∏è  Updating wrapping quantity from', wrappingItem.quantity, 'to', quantity);
              console.log('üìù Updating wrapped product names:', wrappedProductNames);
              await this.updateCartItem(wrappingItem.key, quantity, wrappedProductNames);
            } else {
              console.log('‚úÖ Wrapping already correct - no update needed');
            }
          } else {
            // Add wrapping product for the first time
            console.log('‚ûï Adding wrapping product with quantity:', quantity);
            console.log('üìù With wrapped product names:', wrappedProductNames);
            await this.addWrappingProduct(quantity, wrappedProductNames);
          }
        } else {
          // Remove wrapping if it's in cart
          if (wrappingItem) {
            console.log('‚ûñ REMOVING wrapping product. Key:', wrappingItem.key);
            const removeResult = await this.updateCartItem(wrappingItem.key, 0);
            console.log('‚úÖ Remove request completed. Result:', removeResult);
            
            // Clear localStorage since we're removing all wrapping
            try {
              localStorage.removeItem('gift_wrapping_variant_ids');
              console.log('üóëÔ∏è  Cleared gift wrapping variant IDs from storage');
            } catch (e) {
              console.warn('‚ö†Ô∏è  Could not clear localStorage:', e.message);
            }
            
            // Wait a moment and verify removal
            await new Promise(resolve => setTimeout(resolve, 300));
            const verifyResponse = await fetch('/cart.js?t=' + Date.now());
            const verifyCart = await verifyResponse.json();
            const stillThere = verifyCart.items.some(item => item.product_handle === this.wrappingHandle);
            console.log('‚úîÔ∏è  Verification - Wrapping still in cart?', stillThere ? 'YES (ERROR!)' : 'NO (good!)');
          } else {
            console.log('‚ÑπÔ∏è  No wrapping to remove');
          }
        }
        
        // Refresh cart UI after a longer delay to ensure cart is updated
        console.log('‚è≥ Waiting 500ms before refreshing cart UI...');
        setTimeout(() => this.refreshCartUI(), 500);
      } catch (error) {
        console.error('‚ùå Gift wrapping sync error:', error);
        this.isUpdating = false;
      }
    }

    /**
     * Get names of all wrapped products
     */
    getWrappedProductNames() {
      const checkedBoxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]:checked');
      const names = Array.from(checkedBoxes).map(cb => {
        const parent = cb.closest('.wrapping-item');
        const titleEl = parent?.querySelector('.wrapping-item-title');
        return titleEl?.textContent?.trim() || 'Unknown Product';
      });
      
      // Return as comma-separated string
      return names.join(', ');
    }
    
    /**
     * Add wrapping product to cart
     */
    async addWrappingProduct(quantity, wrappedProductNames = '') {
      if (!this.variantId) {
        this.variantId = await this.getWrappingVariantId();
      }
      
      try {
        console.log('üìù Adding wrapping with variant ID:', this.variantId, 'Quantity:', quantity);
        
        const properties = {
          '_gift_wrapping': 'true'
        };
        
        // Add wrapped product names if available
        if (wrappedProductNames) {
          properties['wrapped_products'] = wrappedProductNames;
          console.log('üìù With wrapped products:', wrappedProductNames);
        }
        
        const response = await fetch('/cart/add.js', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
          },
          body: JSON.stringify({
            items: [{
              id: this.variantId,
              quantity: quantity,
              properties: properties
            }]
          })
        });
        
        const result = await response.json();
        console.log('‚úÖ Wrapping added successfully');
        return result;
      } catch (error) {
        console.error('‚ùå Error adding wrapping product:', error);
        throw error;
      }
    }
    
    /**
     * Update item quantity in cart (and properties if provided)
     */
    async updateCartItem(key, quantity, wrappedProductNames = '') {
      try {
        console.log('üìù Updating cart item. Key:', key, 'New quantity:', quantity);
        
        const updateData = {
          id: key,
          quantity: quantity
        };
        
        // Try to update properties if provided
        if (wrappedProductNames) {
          updateData.properties = {
            'wrapped_products': wrappedProductNames
          };
          console.log('üìù Updating wrapped products:', wrappedProductNames);
        }
        
        const response = await fetch('/cart/change.js', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
          },
          body: JSON.stringify(updateData)
        });
        
        const result = await response.json();
        
        // Log the result
        if (quantity === 0) {
          console.log('‚úÖ Wrapping product removed successfully');
        } else {
          console.log('‚úÖ Cart item updated successfully');
        }
        
        return result;
      } catch (error) {
        console.error('‚ùå Error updating cart item:', error);
        throw error;
      }
    }
    
    /**
     * Fetch wrapping product variant ID
     */
    async getWrappingVariantId() {
      try {
        console.log('üîç Fetching wrapping product:', this.wrappingHandle);
        
        const response = await fetch(`/products/${this.wrappingHandle}.js`);
        if (!response.ok) {
          throw new Error(`Product not found: ${this.wrappingHandle} (HTTP ${response.status})`);
        }
        
        const product = await response.json();
        console.log('üì¶ Product fetched:', product.title);
        
        if (!product.variants || product.variants.length === 0) {
          throw new Error(`No variants found for ${this.wrappingHandle}`);
        }
        
        console.log('‚úÖ Variant ID found:', product.variants[0].id);
        return product.variants[0].id;
      } catch (error) {
        console.error('‚ùå Error fetching wrapping variant:', error);
        throw error;
      }
    }
    
    /**
     * Refresh cart display
     */
    refreshCartUI() {
      console.log('üîÑ Attempting to refresh cart...');
      
      // Method 1: Use theme.cart.buildCart if available
      if (typeof theme !== 'undefined' && theme.cart && typeof theme.cart.buildCart === 'function') {
        console.log('‚úÖ Method 1: Using theme.cart.buildCart()');
        try {
          theme.cart.buildCart();
          console.log('‚úÖ Method 1 succeeded');
          return;
        } catch (e) {
          console.warn('‚ö†Ô∏è  Method 1 failed:', e.message);
        }
      } else {
        console.log('‚ùå Method 1: theme.cart not available');
      }
      
      // Method 2: Try cart:update event
      console.log('üì¢ Method 2: Dispatching cart:update event');
      try {
        document.dispatchEvent(new CustomEvent('cart:update'));
        console.log('‚úÖ Method 2: Event dispatched');
      } catch (e) {
        console.warn('‚ö†Ô∏è  Method 2 failed:', e.message);
      }
      
      // Method 3: Aggressive DOM update with multiple selectors
      console.log('üîó Method 3: Fetching and updating cart DOM...');
      this.updateCartDOMDirectly();
      
      // Method 4: Fallback reload after delay
      console.log('‚è∞ Method 4: Setting reload timeout...');
      this.reloadTimeout = setTimeout(() => {
        console.log('‚ö†Ô∏è  Method 4: Page reload fallback triggered');
        window.location.reload();
      }, 3000);
    }

    updateCartDOMDirectly() {
      // Try to update cart sections directly via AJAX
      const sections = ['cart-drawer', 'cart-items', 'cart-page'];
      
      Promise.all(sections.map(section => 
        fetch(`/cart?section_id=${section}`)
          .then(r => r.text())
          .catch(e => {
            console.warn(`‚ö†Ô∏è  Could not fetch section ${section}:`, e.message);
            return null;
          })
      )).then(([drawerHtml, itemsHtml, pageHtml]) => {
        let updated = false;
        
        // Try to update cart drawer
        if (drawerHtml) {
          const drawer = document.getElementById('cart-drawer');
          if (drawer) {
            try {
              const parser = new DOMParser();
              const newDOM = parser.parseFromString(drawerHtml, 'text/html');
              const newDrawer = newDOM.getElementById('cart-drawer');
              if (newDrawer) {
                drawer.innerHTML = newDrawer.innerHTML;
                console.log('‚úÖ Method 3a: Cart drawer updated');
                updated = true;
                // Restore checkbox states after DOM update
                setTimeout(() => {
                  // Allow re-initialization for this new DOM
                  this.isInitialized = false;
                  this.syncCheckboxStateFromStorage();
                  this.attachCheckboxListeners();
                }, 50);
              }
            } catch (e) {
              console.warn('‚ö†Ô∏è  Method 3a failed:', e.message);
            }
          }
        }
        
        // Try to update cart items container
        if (itemsHtml) {
          const items = document.getElementById('cart-items');
          if (items) {
            try {
              const parser = new DOMParser();
              const newDOM = parser.parseFromString(itemsHtml, 'text/html');
              const newItems = newDOM.getElementById('cart-items');
              if (newItems) {
                items.innerHTML = newItems.innerHTML;
                console.log('‚úÖ Method 3b: Cart items updated');
                updated = true;
                // Restore checkbox states after DOM update
                setTimeout(() => {
                  // Allow re-initialization for this new DOM
                  this.isInitialized = false;
                  this.syncCheckboxStateFromStorage();
                  this.attachCheckboxListeners();
                }, 50);
              }
            } catch (e) {
              console.warn('‚ö†Ô∏è  Method 3b failed:', e.message);
            }
          }
        }
        
        // Try to update cart subtotal and totals
        fetch('/cart.js').then(r => r.json()).then(cart => {
          // Update item count elements
          document.querySelectorAll('[data-cart-count]').forEach(el => {
            el.setAttribute('data-cart-count', cart.item_count);
            el.textContent = cart.item_count;
            console.log('‚úÖ Method 3c: Updated cart count to', cart.item_count);
            updated = true;
          });
          
          // Update subtotal elements
          document.querySelectorAll('[data-cart-subtotal]').forEach(el => {
            el.setAttribute('data-cart-subtotal', cart.total_price);
            el.textContent = (cart.total_price / 100).toFixed(2);
            console.log('‚úÖ Method 3d: Updated cart subtotal');
            updated = true;
          });
        });
        
        if (updated) {
          console.log('‚úÖ Method 3: At least one cart element was updated');
        } else {
          console.warn('‚ö†Ô∏è  Method 3: No cart elements found to update');
        }
      });
    }
  }
  
  // Global instance
  window.giftWrappingManager = null;
  
  async function initGiftWrapping() {
    const container = document.querySelector('[data-wrapping-container]');
    
    if (container) {
      console.log('‚úÖ üéÅ Wrapping container FOUND! Initializing gift wrapping...');
      
      if (!window.giftWrappingManager) {
        window.giftWrappingManager = new GiftWrappingManager();
      }
      
      await window.giftWrappingManager.init();
    } else {
      console.log('‚ùå Wrapping container NOT FOUND in DOM');
      
      // Check if the snippet is enabled
      const settingEnabled = {{ settings.cart_wrapping_enable | json }};
      console.log('üìã Gift wrapping enabled in settings:', settingEnabled);
      
      // Check if there are cart items
      const cartItems = document.querySelectorAll('[data-products] [data-cart-item]');
      console.log('üì¶ Cart items found:', cartItems.length);
      
      if (settingEnabled && cartItems.length === 0) {
        console.log('‚ÑπÔ∏è  Cart is empty - wrapping section should appear once items are added');
      }
    }
  }
  
  /**
   * Watch for the wrapping container to appear in the DOM
   * This handles cases where cart is loaded dynamically
   */
  function watchForWrappingContainer() {
    console.log('üëÄ Setting up DOM watcher for wrapping container...');
    
    const observer = new MutationObserver((mutations) => {
      const container = document.querySelector('[data-wrapping-container]');
      if (container) {
        console.log('‚úÖ üëÄ Wrapping container detected in DOM via MutationObserver!');
        observer.disconnect();
        initGiftWrapping();
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: false
    });
  }
  
  // Initialize on page load
  if (document.readyState === 'loading') {
    console.log('üìÑ Page loading... waiting for DOMContentLoaded');
    document.addEventListener('DOMContentLoaded', () => {
      console.log('üìÑ DOMContentLoaded fired');
      initGiftWrapping();
      watchForWrappingContainer();
    });
  } else {
    console.log('üìÑ Page already loaded, initializing now');
    initGiftWrapping();
    watchForWrappingContainer();
  }
  
  // Reinitialize after cart updates
  document.addEventListener('cart:updated', () => {
    console.log('üì¢ cart:updated event fired, reinitializing gift wrapping...');
    setTimeout(initGiftWrapping, 200);
  });
  
  // Hook into theme cart system
  if (typeof theme !== 'undefined') {
    console.log('‚úÖ Theme object found, hooking into cart system');
    
    const hookCartBuild = () => {
      if (theme.cart && theme.cart.reInit) {
        const originalReInit = theme.cart.reInit;
        theme.cart.reInit = function() {
          console.log('üîÑ theme.cart.reInit called, reinitializing gift wrapping');
          originalReInit.call(this);
          setTimeout(initGiftWrapping, 100);
        };
        console.log('‚úÖ Successfully hooked theme.cart.reInit');
      } else {
        console.log('‚ö†Ô∏è  Could not find theme.cart.reInit to hook into');
      }
    };
    
    hookCartBuild();
  } else {
    console.log('‚ö†Ô∏è  Theme object not found, will retry after delay');
    
    setTimeout(() => {
      if (typeof theme !== 'undefined' && theme.cart && theme.cart.reInit) {
        console.log('‚úÖ Theme loaded, hooking into cart system');
        
        const originalReInit = theme.cart.reInit;
        theme.cart.reInit = function() {
          console.log('üîÑ theme.cart.reInit called');
          originalReInit.call(this);
          setTimeout(initGiftWrapping, 100);
        };
      } else {
        console.log('‚ùå Could not find theme object after retry');
      }
    }, 1500);
  }
})();
</script>
{% endif %}

</body>
</html>