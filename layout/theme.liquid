<!doctype html>
<html class="no-js" lang="{{ request.locale.iso_code }}" dir="{{ settings.text_direction }}">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="theme-color" content="{{ settings.color_button }}">
  <link rel="canonical" href="{{ canonical_url }}">
  <link rel="preconnect" href="https://cdn.shopify.com" crossorigin>
  <link rel="preconnect" href="https://fonts.shopifycdn.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="dns-prefetch" href="https://productreviews.shopifycdn.com">
  <link rel="dns-prefetch" href="https://ajax.googleapis.com">
  <link rel="dns-prefetch" href="https://maps.googleapis.com">
  <link rel="dns-prefetch" href="https://maps.gstatic.com">

  {%- if settings.favicon != blank -%}
    <link rel="shortcut icon" href="{{ settings.favicon | img_url: '32x32' }}" type="image/png" />
  {%- endif -%}

  {%- render 'seo-title' -%}

  {%- if page_description -%}
  <meta name="description" content="{{ page_description | escape }}">
  {%- endif -%}

  {%- render 'social-meta-tags' -%}

  {%- render 'font-face' -%}
  {{ 'theme.css' | asset_url | stylesheet_tag: preload: true }}
  {%- render 'css-variables' -%}

  <script>
    document.documentElement.className = document.documentElement.className.replace('no-js', 'js');

    window.theme = window.theme || {};
    theme.routes = {
      home: "{{ routes.root_url }}",
      cart: "{{ routes.cart_url | append: '.js' }}",
      cartPage: "{{ routes.cart_url }}",
      cartAdd: "{{ routes.cart_add_url | append: '.js' }}",
      cartChange: "{{ routes.cart_change_url | append: '.js' }}",
      search: "{{ routes.search_url }}",
      predictiveSearch: "{{ routes.predictive_search_url }}"
    };
    theme.strings = {
      soldOut: {{ 'products.product.sold_out' | t | json }},
      unavailable: {{ 'products.product.unavailable' | t | json }},
      inStockLabel: {{ 'products.product.in_stock_label' | t | json }},
      oneStockLabel: {{ 'products.product.stock_label.one' | t: count: '[count]' | json }},
      otherStockLabel: {{ 'products.product.stock_label.other' | t: count: '[count]' | json }},
      willNotShipUntil: {{ 'products.product.will_not_ship_until' | t: date: '[date]' | json }},
      willBeInStockAfter: {{ 'products.product.will_be_in_stock_after' | t: date: '[date]' | json }},
      waitingForStock: {{ 'products.product.waiting_for_stock' | t | json }},
      savePrice: {{ 'products.general.save_html' | t: saved_amount: '[saved_amount]' | json }},
      cartEmpty: {{ 'cart.general.empty' | t | json }},
      cartTermsConfirmation: {{ 'cart.general.terms_confirm' | t | json }},
      searchCollections: {{ 'general.search.collections' | t | json }},
      searchPages: {{ 'general.search.pages' | t | json }},
      searchArticles: {{ 'general.search.articles' | t | json }},
      productFrom: {{ 'products.general.from_text_html' | t: price: '' | json }},
      maxQuantity: {{ 'cart.general.max_quantity' | t: quantity: '[quantity]', title: '[title]' | json }}
    };
    theme.settings = {
      cartType: {{ settings.cart_type | json }},
      isCustomerTemplate: {% if request.page_type contains 'customers/' %}true{% else %}false{% endif %},
      moneyFormat: {{ shop.money_format | json }},
      saveType: {{ settings.product_save_type | json }},
      productImageSize: {{ settings.product_grid_image_size | json }},
      productImageCover: {{ settings.product_grid_image_fill }},
      predictiveSearch: {{ settings.predictive_search_enabled }},
      predictiveSearchType: {{ settings.search_type | json }},
      predictiveSearchVendor: {{ settings.predictive_search_show_vendor | json }},
      predictiveSearchPrice: {{ settings.predictive_search_show_price | json }},
      quickView: {{ settings.quick_shop_enable }},
      themeName: 'Impulse',
      themeVersion: "8.0.0"
    };
  </script>

  {{ content_for_header }}

  <script src="{{ 'vendor-scripts-v11.js' | asset_url | split: '?' | first }}" defer="defer"></script>

  {%- if shop.enabled_currencies.size > 1 -%}
    <link rel="stylesheet" href="{{ 'country-flags.css' | asset_url | split: '?' | first }}">
  {%- endif -%}

  <script src="{{ 'theme.js' | asset_url }}" defer="defer"></script>

  {%- if request.page_type contains 'customers/' -%}
    <script src="{{ 'shopify_common.js' | shopify_asset_url }}" defer="defer"></script>
  {%- endif -%}

  {% if request.design_mode %}
    <script>theme.settings.email = {{ shop.email | json }}</script>
    <script src="https://api.archetypethemes.co/design-mode.js" defer="defer"></script>
  {% endif %}
</head>

<body class="template-{{ template | replace: '.', ' ' | truncatewords: 1, '' | handle }}{% if request.path == '/challenge' %} template-challange{% endif %}" data-center-text="{{ settings.type_body_align_text }}" data-button_style="{{ settings.button_style }}" data-type_header_capitalize="{{ settings.type_header_capitalize }}" data-type_headers_align_text="{{ settings.type_headers_align_text }}" data-type_product_capitalize="{{ settings.type_product_capitalize }}" data-swatch_style="{{ settings.swatch_style }}" {% if settings.disable_animations %}data-disable-animations="true"{% endif %}>

  <a class="in-page-link visually-hidden skip-link" href="#MainContent">{{ 'general.accessibility.skip_to_content' | t }}</a>

  <div id="PageContainer" class="page-container">
    <div class="transition-body">

    {%- sections 'header-group' -%}
    {%- sections 'popup-group' -%}

      <main class="main-content" id="MainContent">
        {{ content_for_layout }}
      </main>

    {%- sections 'footer-group' -%}

    </div>
  </div>

  {%- liquid
    render 'video-modal'
    render 'photoswipe-template'
    render 'tool-tip'
  -%}

  {% comment %} Image markup used when building product grid item via JS {% endcomment %}
  <template id="naturalImageMarkup">
    <div class="image-wrap" style="height: 0;">
      <image-element data-aos="image-fade-in" data-aos-offset="150">
        <img class="grid-product__image image-element" width height src srcset loading="lazy" alt>
      </image-element>
    </div>
  </template>
  <template id="fixedRatioImageMarkup">
    <div class="grid__image-ratio">
      <image-element data-aos="image-fade-in" data-aos-offset="150">
        <img class="image-element" width height src srcset loading="lazy" alt>
      </image-element>
    </div>
  </template>







{% comment %} <style>
.site-header {
  position: fixed;
  top: 15px;
  left: 0;
  width: 100%;
  z-index: 9999;
  transition: top 0.3s ease-in-out;
}
</style>

<script>
document.addEventListener("DOMContentLoaded", function () {
  let lastScroll = window.pageYOffset;
  const header = document.querySelector(".site-header");

  window.addEventListener("scroll", function () {
    let currentScroll = window.pageYOffset;

    if (currentScroll > lastScroll && currentScroll > 50) {
      // Scroll down → hide header
      header.style.top = `-${header.offsetHeight}px`;
    } else {
      // Scroll up → show header
      header.style.top = "15px";
    }

    lastScroll = currentScroll;
  });
});
</script>

<style>
  @media only screen and (max-width: 768px) {
  .collection-filter {
    flex-wrap: wrap;
    justify-content: space-between;
    position: static !important;

    top: 17px;
    z-index: 5;
  }
}</style> {% endcomment %}

{% if settings.cart_wrapping_enable %}
<script>
(function() {
  'use strict';
  
  const wrappingHandle = {{ settings.cart_wrapping_product_handle | default: 'special-wrapping' | json }};
  const perItemMode = {{ settings.cart_wrapping_per_item | json }};
  
  class GiftWrappingManager {
    constructor() {
      this.wrappingHandle = wrappingHandle;
      this.perItemMode = perItemMode;
      this.isUpdating = false;
      this.initialized = false;
      this.cartState = {}; // Binary tracking: itemKey -> isInCart (1/0)
      this.checkedState = {}; // Track which items should be wrapped
    }
    
    init() {
      if (this.initialized) {
        this.detachEvents();
      }
      
      // Update cart state tracking
      this.updateCartState();
      
      if (this.perItemMode) {
        this.initPerItemMode();
      } else {
        this.initBulkMode();
      }
      
      this.initialized = true;
    }
    
    updateCartState() {
      // Build binary state map of current cart items
      const newState = {};
      const allItems = document.querySelectorAll('.wrapping-checkbox[data-item-key]');
      
      allItems.forEach(checkbox => {
        const key = checkbox.dataset.itemKey;
        newState[key] = 1; // Item exists in cart
        
        // Preserve checked state if item existed before
        if (this.cartState[key] === 1 && this.checkedState[key]) {
          checkbox.checked = true;
          this.checkedState[key] = true;
        } else if (!this.checkedState[key]) {
          this.checkedState[key] = checkbox.checked;
        }
      });
      
      // Detect removed items (was 1, now 0)
      const removedItems = Object.keys(this.cartState).filter(key => 
        this.cartState[key] === 1 && !newState[key]
      );
      
      // Clean up checked state for removed items
      removedItems.forEach(key => {
        delete this.checkedState[key];
      });
      
      this.cartState = newState;
      
      // Auto-update wrapping if items were removed and we're in bulk mode or per-item with changes
      if (removedItems.length > 0) {
        setTimeout(() => this.autoUpdateWrapping(), 100);
      }
    }
    
    async autoUpdateWrapping() {
      if (this.isUpdating) return;
      
      if (this.perItemMode) {
        // In per-item mode, recalculate based on checked boxes
        const checkedBoxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]:checked');
        const totalToWrap = Array.from(checkedBoxes).reduce((sum, cb) => {
          return sum + parseInt(cb.dataset.itemQuantity || 1);
        }, 0);
        await this.updateWrappingQuantity(totalToWrap);
      } else {
        // In bulk mode, update count if master is checked
        const masterCheckbox = document.querySelector('[data-wrapping-master]');
        if (masterCheckbox && masterCheckbox.checked) {
          const allItems = document.querySelectorAll('[data-wrapping-item]');
          const totalItems = allItems.length;
          masterCheckbox.dataset.totalItems = totalItems;
          
          const countSpan = document.querySelector('[data-wrapping-count]');
          if (countSpan) {
            countSpan.textContent = totalItems;
          }
          
          await this.updateWrappingQuantity(totalItems);
        }
      }
    }
    
    detachEvents() {
      const oldCheckboxes = document.querySelectorAll('.wrapping-checkbox');
      oldCheckboxes.forEach(cb => {
        const newCb = cb.cloneNode(true);
        cb.parentNode.replaceChild(newCb, cb);
      });
    }
    
    initPerItemMode() {
      const checkboxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]');
      checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', (e) => this.handlePerItemChange(e));
      });
    }
    
    initBulkMode() {
      const masterCheckbox = document.querySelector('[data-wrapping-master]');
      if (masterCheckbox) {
        masterCheckbox.addEventListener('change', (e) => this.handleBulkChange(e));
      }
    }
    
    async handlePerItemChange(event) {
      if (this.isUpdating) return;
      
      const checkbox = event.target;
      const key = checkbox.dataset.itemKey;
      this.checkedState[key] = checkbox.checked;
      
      const checkedBoxes = document.querySelectorAll('.wrapping-checkbox[data-item-key]:checked');
      const totalToWrap = Array.from(checkedBoxes).reduce((sum, cb) => {
        return sum + parseInt(cb.dataset.itemQuantity || 1);
      }, 0);
      
      await this.updateWrappingQuantity(totalToWrap);
    }
    
    async handleBulkChange(event) {
      if (this.isUpdating) return;
      
      const checkbox = event.target;
      const totalItems = parseInt(checkbox.dataset.totalItems || 0);
      const quantity = checkbox.checked ? totalItems : 0;
      
      await this.updateWrappingQuantity(quantity);
    }
    
    async updateWrappingQuantity(quantity) {
      this.isUpdating = true;
      
      try {
        const cartResponse = await fetch('/cart.js');
        const cart = await cartResponse.json();
        
        const wrappingItem = cart.items.find(item => 
          item.product_handle === this.wrappingHandle
        );
        
        if (quantity > 0) {
          if (wrappingItem) {
            if (wrappingItem.quantity !== quantity) {
              await this.changeItemQuantity(wrappingItem.key, quantity);
            }
          } else {
            await this.addWrappingProduct(quantity);
          }
        } else {
          if (wrappingItem) {
            await this.changeItemQuantity(wrappingItem.key, 0);
          }
        }
        
        await this.refreshCart();
      } catch (error) {
        console.error('Error updating wrapping:', error);
      } finally {
        this.isUpdating = false;
      }
    }
    
    async addWrappingProduct(quantity) {
      const variantId = await this.getWrappingVariantId();
      const formData = {
        items: [{
          id: variantId,
          quantity: quantity,
          properties: {
            '_gift_wrapping': 'true'
          }
        }]
      };
      
      const response = await fetch('/cart/add.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData)
      });
      
      return response.json();
    }
    
    async changeItemQuantity(key, quantity) {
      const response = await fetch('/cart/change.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          id: key,
          quantity: quantity
        })
      });
      
      return response.json();
    }
    
    async getWrappingVariantId() {
      const response = await fetch(`/products/${this.wrappingHandle}.js`);
      const product = await response.json();
      return product.variants[0].id;
    }
    
    async refreshCart() {
      if (typeof theme !== 'undefined' && theme.cart) {
        theme.cart.buildCart();
      } else {
        if (window.location.pathname === '/cart') {
          window.location.reload();
        }
      }
    }
  }
  
  // Create global instance
  window.giftWrappingManager = null;
  
  function initGiftWrapping() {
    const wrappingContainer = document.querySelector('[data-wrapping-container]');
    if (wrappingContainer) {
      if (!window.giftWrappingManager) {
        window.giftWrappingManager = new GiftWrappingManager();
      }
      window.giftWrappingManager.init();
    }
  }
  
  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGiftWrapping);
  } else {
    initGiftWrapping();
  }
  
  // Reinitialize after cart updates (for cart drawer)
  document.addEventListener('cart:updated', function() {
    setTimeout(initGiftWrapping, 100);
  });
  
  // Hook into theme cart buildCart if available
  function hookCartBuild() {
    if (typeof theme !== 'undefined' && theme.cart && theme.cart.reInit) {
      const originalReInit = theme.cart.reInit;
      theme.cart.reInit = function() {
        originalReInit.call(this);
        setTimeout(initGiftWrapping, 50);
      };
    }
  }
  
  // Try to hook immediately or after theme loads
  if (typeof theme !== 'undefined') {
    hookCartBuild();
  } else {
    setTimeout(hookCartBuild, 500);
  }
})();
</script>
{% endif %}

</body>
</html>